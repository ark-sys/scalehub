#!/usr/bin/env python3
import argparse
from time import sleep

from scripts.src.Client import Client
from scripts.src.data.DataManager import DataManager
from scripts.src.platforms.ProvisionManager import ProvisionManager
from scripts.src.resources.KubernetesManager import KubernetesManager
from scripts.utils.Config import Config
from scripts.utils.Defaults import DefaultKeys as Key
from scripts.utils.Logger import Logger
from scripts.utils.Tools import Tools, Playbooks


# Build cluster and install dependencies
def provision(config: Config):
    platforms = config.get(Key.Platforms.platforms)

    if platforms is not None:
        log.info(f"Found {len(platforms)} platforms to provision.")
        pm: ProvisionManager = ProvisionManager(log, config, platforms)

        # Initialize inventory file with requested nodes from config
        pm.provision()

        # Platforms are provisioned, create runtime file
        config.create_runtime_file()

        # Provisition should be complete, deploy infrastructure
        p: Playbooks = Playbooks(log)
        try:
            p.run("infrastructure/setup", tag="create", config=config)
        except Exception as e:
            log.error(f"Error during infrastructure setup: {e}")
            exit(1)
    else:
        log.error("No platforms are specified in the configuration file.")


# Destroy cluster
def destroy(config: Config):
    platforms = config.get(Key.Platforms.platforms)

    if platforms is not None:
        log.info(f"Found {len(platforms)} platforms to destroy.")
        pm: ProvisionManager = ProvisionManager(log, config, platforms)
        pm.destroy()
    else:
        log.error("No platforms are specified in the configuration file.")

    # Delete runtime file
    config.delete_runtime_file()


# Execute tasks with "deploy" tag for a given playbook
def deploy(playbook, config: Config):
    log.info(f"Executing deployment tasks in playbook : {playbook} ...")
    p: Playbooks = Playbooks(log)
    tag = "create"
    try:
        if playbook == "application/load_generators":
            for lg_config in config.get(Key.Experiment.Generators.generators):
                load_generator_params = {
                    "lg_name": lg_config["name"],
                    "lg_topic": lg_config["topic"],
                    "lg_type": lg_config["type"],
                    "lg_numsensors": int(lg_config["num_sensors"]),
                    "lg_intervalms": int(lg_config["interval_ms"]),
                    "lg_replicas": int(lg_config["replicas"]),
                    "lg_value": int(lg_config["value"]),
                }
                p.run(
                    playbook,
                    config=config,
                    tag=tag,
                    extra_vars=load_generator_params,
                )
        else:
            p.run(playbook, config=config, tag=tag)
    except Exception as e:
        log.error(f"Error during deployment: {e}")
        exit(1)
    return


# Execute tasks with "delete" tag for a given playbook
def delete(playbook, config: Config):
    log.info(f"Executing deletion tasks in playbook : {playbook} ...")
    p: Playbooks = Playbooks(log)
    tag = "delete"
    try:
        if playbook == "application/load_generators":
            for lg_config in config.get(Key.Experiment.Generators.generators):
                load_generator_params = {
                    "lg_name": lg_config["name"],
                    "lg_topic": lg_config["topic"],
                    "lg_type": lg_config["type"],
                    "lg_numsensors": int(lg_config["num_sensors"]),
                    "lg_intervalms": int(lg_config["interval_ms"]),
                    "lg_replicas": int(lg_config["replicas"]),
                    "lg_value": int(lg_config["value"]),
                }
                p.run(
                    playbook,
                    config=config,
                    tag=tag,
                    extra_vars=load_generator_params,
                )

        else:
            p.run(playbook, config=config, tag=tag)
    except Exception as e:
        log.error(f"Error during deletion: {e}")
        exit(1)
    return


# Delete and re-deploy 'playbook' parameter
def reload(playbook, config: Config):
    # Delete running playbook
    delete(playbook, config)
    # Give some time for tasks to execute
    sleep(5)
    # Deploy again playbook
    deploy(playbook, config)


def experiment(action, config: Config):
    c: Client = Client(log, config)
    match action:
        case "start":
            c.start()
        case "stop":
            c.stop()
        case "clean":
            c.clean()
        case "check":
            c.check()
        case _:
            log.error(f"Action {action} is not implemented for command 'experiment'.")


# Get tokens for minio and kubernetes dashboard
def tokens():
    k: KubernetesManager = KubernetesManager(log)

    # Retrieve token for minio console
    minio_console_token = k.get_token("console-sa-secret", "minio-operator")
    kubernetes_dashboard_token = k.get_token("admin-user", "kubernetes-dashboard")

    # Print tokens in a readable format and easy to copy-paste
    log.info(f"Minio Console Token : \n{minio_console_token}\n\n")
    log.info(f"Kubernetes Dashboard Token : \n{kubernetes_dashboard_token}\n\n")


# Export data for a given date, experiment number at date or multirun experiment at date or experiment number at multirun experiment at date
def export(config: Config, exp_path):
    log.info("Exporting...")

    dm: DataManager = DataManager(log, config)

    dm.export(exp_path)


def sync_experiment_data(config: Config):
    log.info("Syncing experiment data...")
    t: Tools = Tools(log)
    t.sync_data(config.get_str(Key.Scalehub.experiments))


def main(log: Logger):
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest="command")

    parser.add_argument(
        "-c",
        "--conf",
        dest="conf_file",
        action="store",
        default=Config.RUNTIME_PATH,
        help="Specify a custom path for the configuration used for either provisioning or experiment running.",
    )
    # Provision command
    subparsers.add_parser(
        "provision", help="Provision platform specified in conf/scalehub.conf"
    )

    # Destroy command
    subparsers.add_parser(
        "destroy", help="Destroy platform specified in conf/scalehub.conf"
    )

    # Deploy command
    deploy_parser = subparsers.add_parser(
        "deploy", help="Executes deploy tasks of provided playbook."
    )
    deploy_parser.add_argument("playbook", help="Name of the playbook.")

    # Delete command
    delete_parser = subparsers.add_parser(
        "delete", help="Executes delete tasks of provided playbook."
    )
    delete_parser.add_argument("playbook", help="Name of the playbook.")

    # Reload command
    reload_parser = subparsers.add_parser(
        "reload", help="Executes reload tasks of provided playbook."
    )
    reload_parser.add_argument("playbook", help="Name of the playbook.")

    # Experiment command
    experiment_parser = subparsers.add_parser(
        "experiment", help="Executes experiment tasks."
    )
    experiment_parser.add_argument("action", help="Name of the action.")

    # Tokens command
    subparsers.add_parser(
        "tokens", help="Get tokens for minio and kubernetes dashboard"
    )

    # Sync command
    subparsers.add_parser("sync", help="Sync experiment data from remote to local")

    # Reservation time command
    subparsers.add_parser("reservation_time", help="Get remaining reservation time")

    # Export command
    export_subparser = subparsers.add_parser("export", help="Export data")
    export_subparser.add_argument(
        "date", help="Provide experiment path in format 'DD-MM-YYYY/N'"
    )

    # Parse command line arguments
    args = parser.parse_args()

    # TODO simplify this
    # Parse configuration file values
    configuration_file = args.conf_file
    match args.command:
        case "destroy":
            config = Config(log, Config.RUNTIME_PATH)
        case "export":
            config = Config(log, Config.DEFAULTS_PATH)
        case _:
            config = Config(log, configuration_file)

    match args.command:
        case "destroy":
            destroy(config)
        case "provision":
            provision(config)
        case "deploy":
            deploy(args.playbook, config)
        case "delete":
            delete(args.playbook, config)
        case "reload":
            reload(args.playbook, config)
        case "experiment":
            experiment(args.action, config)
        case "tokens":
            tokens()
        case "sync":
            sync_experiment_data(config)
        case "export":
            date = args.date
            export(config, date)
        case _:
            parser.print_help()


if __name__ == "__main__":
    log = Logger()
    main(log)
